## Shell Scripting

# A '\' mark before a command will ignore aliases. For example, you have alias
# alias ls='ls --color=auto', and want use ls without that --color option
\ls

# Turn on debugging:
set -x

# Turn off debugging:
set +x

# To implement a case command:
case "$1"
in
  0) echo "zero found";;
  1) echo "one found";;
  2) echo "two found";;
  3*) echo "something beginning with 3 found";;
esac

# Retrieve N-th piped command exit status
printf 'foo' | fgrep 'foo' | sed 's/foo/bar/'
echo ${PIPESTATUS[0]}  # replace 0 with N

# To implement a for loop:
for file in *;
do
  echo $file found;
done

# Use a for Loop at the Command Line
for VAR in LIST

# do
# # use $VAR
# done

# When you need to perform the same action for a list of items, you can use a
# for loop right from your shell.

for USER in bob jill fred

# > do
# > sudo passwd -l $USER
# > logger -t naughty-user $USER
# > done
# Locking password for user bob.
# passwd: Success
# Locking password for user jill.
# passwd: Success
# Locking password for user fred.
# passwd: Success

sudo tail -3 /var/log/messages

# Apr 8 19:29:03 linuxserver naughty-user: bob
# Apr 8 19:29:03 linuxserver naughty-user: jill
# Apr 8 19:29:03 linuxserver naughty-user: fred

# You can also type entire loop on one command line

for USER in bob jill fred; do sudo passwd -l $USER; logger -t naughty-user $USER; done

# Read in Input One Line at a Time

while read LINE

# > do
# >  # Do something with $LINE
# > done < file.txt

command | while read LINE

# > do
# >  # Do something with $LINE
# > done

# If you want to iterate over a list of words, use a for loop. If you want to
# iterate over a line, use a while loop in combination with a read statement and
# redirection.

# Let's look for file systems that are over 90% utilized. If we try to use an if
# statement it will break up the output into word chunks like this.

df | head -1

# Filesystem 1K-blocksUsed Available Use% Mounted on

for x in $(df)

# > do
# > echo $x
# > done
# Filesystem
# 1K-blocks
# Used
# Available
# Use%
# Mounted
# on
# ...

# We need to read in entire lines at a time like this.

df | while read LINE

# > do
# > echo $LINE
# > done
# Filesystem 1K-blocks Used Available Use% Mounted on
# ...

# Here is one way to find file systems that are over 90% utilized.

df

# Filesystem 1K-blocksUsed Available Use% Mounted on
# /dev/sda2 28891260 3270340  25327536 12% /
# tmpfs    515320   72515248  1% /dev/shm
# /dev/sda1  495844 453683 16561 97% /boot

df | grep [0-9]% | while read LINE

# > do
# >  use=$(echo $LINE | awk '{print $5}' | tr -d '%')
# >  mountpoint=$(echo $LINE | awk '{print $6}')
# > [ $use -gt 90 ] && echo "$mountpoint is over 90% utilized."
# > done
# /boot is over 90% utilized.

# Instead of assigning variables within the while loop, you can assign them with
# the read statement. Here is how this method looks.

df | grep [0-9]% | while read fs blocks used available use mountpoint

# > do
# >  use=$(echo $use | tr -d '%')
# >  [ $use -gt 90 ] && echo "$mountpoint is over 90% utilized."
# > done
# /boot is over 90% utilized.

# Accept User Input and Store It in a Variable

read VAR
read -n 1 VAR
read -p "Prompt text" VAR

# Lock file:
( set -o noclobber; echo > my.lock ) || echo 'Failed to create lock file'
