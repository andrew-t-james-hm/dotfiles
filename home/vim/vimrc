"
" Personal preference .vimrc file
"
" My personally preferred version of vim is the one with the "HUGE" feature
" set, in addition to the following configure options:
"
"     ./configure --with-features=huge
"                 --enable-pythoninterp --enable-rubyinterp
"                 --enable-perlinterp --with-macarchs=x86_64
"                 --with-macsdk=10.6 --enable-multibyte
"                 --enable-cscope --prefix=/usr/local
"
" To start vim without using this .vimrc file, use:
"     vim -u NORC
"
" To start vim without loading any .vimrc or plugins, use:
"     vim -u NONE
"

" Use vim settings, rather then vi settings (much better!)
" This must be first, because it changes other options as a side effect.
set nocompatible

" Preamble -------------------------------------------------------------------- {{{

" Use pathogen to easily modify the runtime path to include all plugins under
" the ~/.vim/bundle directory
filetype off                    " force reloading *after* pathogen loaded
silent! call pathogen#helptags()
silent! call pathogen#runtime_append_all_bundles()
filetype plugin indent on       " enable detection, plugins and indenting in one step

" }}}
" Basic options --------------------------------------------------------------- {{{

set modelines=0
set updatecount=50 "write swap file to disk after 50 keystrokes
set scrolljump=5
set scrolloff=4                 " keep 4 lines off the edges of the screen when scrolling
set autoindent " always set autoindenting on
set copyindent    " copy the previous indentation on autoindenting
set showmode                    " always show what mode we're currently editing in
set whichwrap=b,s,h,l,<,>,[,]
set backspace=indent,eol,start    " allow backspacing over everything in insert mode
set number        " always show line numbers
set relativenumber
set cpoptions+=J
set listchars=tab:▸\ ,eol:¬
set shell=/bin/bash
set showbreak=↪
set splitbelow
set splitright
set ignorecase    " ignore case when searching
set smartcase     " ignore case if search pattern is all lowercase,
                  "    case-sensitive otherwise

set nrformats=octal,hex,alpha " Enable CTRL-A/CTRL-X to work on octal and hex numbers, as well as characters
set smarttab      " insert tabs on the start of a line according to
                  "    shiftwidth, not tabstop
set incsearch     " show search matches as you type                 
set showmatch     " when a bracket is inserted, breifly jump to a matching one
set matchtime=2   " jump to matching bracket for 2/10th of a second
set hlsearch      " highlight search terms
set gdefault                    " search/replace "globally" (on a line) by default
set nolist                      " don't show invisible characters by default,
                                " but it is enabled for some file types (see later)
set virtualedit=all             " allow the cursor to go in to "invalid" places

" Remember things between sessions
"
" '20  - remember marks for 20 previous files
" \"50 - save 50 lines for each register
" :20  - remember 20 items in command-line history 
" %    - remember the buffer list (if vim started without a file arg)
" n    - set name of viminfo file
set viminfo='20,\"50,:20,%,n~/.viminfo

" Editor layout {{{

set termencoding=utf-8
set encoding=utf-8
set lazyredraw                  " don't update the display while executing macros
set cmdheight=1                 " use a status bar that is 2 rows high

" }}}
" Tabs, spaces, wrapping {{{

set tabstop=2
set shiftwidth=2 " number of spaces to use for autoindenting
set shiftround    " use multiple of shiftwidth when indenting with '<' and '>'
set softtabstop=2
set expandtab                   " expand tabs by default (overloadable per file type later)
set nowrap                      " don't wrap lines
set textwidth=120
set formatoptions+=1            " When wrapping paragraphs, don't end lines
                                "    with 1-letter words (looks stupid)
" set colorcolumn=+1

" }}}
" Par {{{

"set formatprg=par\ -w78
":map <A-q> {v}!par -jw78<CR>
":vmap <A-q> !par -jw78<CR>

" }}}
" Vim behaviour {{{
set hidden                      " hide buffers instead of closing them this
                                "    means that the current buffer can be put
                                "    to background without being written; and
                                "    that marks and undo history are preserved
set switchbuf=useopen           " reveal already opened files from the
                                " quickfix window instead of opening new
                                " buffers
set history=1000                " remember more commands and search history
set undolevels=1000             " use many muchos levels of undo
set undoreload=10000
if v:version >= 730
    set undofile                " keep a persistent backup file
    set undodir=~/.vim/tmp/undo//     " undo files
endif
set nobackup                    " do not keep backup files, it's 70's style cluttering
set noswapfile                  " do not write annoying intermediate swap files,
                                "    who did ever restore from swap files anyway?
set backupdir=~/.vim/tmp/backup// " backups
set directory=~/vim/tmp/swap//   " swap files
                                " store swap files in one of these directories
                                "    (in case swapfile is ever turned on)
set wildmenu                    " make tab completion for files/buffers act like bash
set wildmode=list:longest,full  " show a list when pressing tab and complete
                                "    first full match
set wildignore=*.swp,*.bak,*.pyc,*.class
set title                       " change the terminal's title
set visualbell                  " don't beep
set noerrorbells                " don't beep
set nomodeline                  " disable mode lines (security measure)
"set ttyfast                     " always use a fast terminal
set cursorline                  " underline the current line, for quick orientation

if has('cmdline_info')
  set ruler                   " show the ruler
  set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " a ruler on steroids
  set showcmd                   " show (partial) command in the last line of the screen
                                "    this also shows visual selection info
endif


" }}}    
" Status line {{{

if has('statusline')
  set laststatus=2                " tell VIM to always put a status line in, even
                                "    if there is only one window
  "set statusline=\ \ \ \ \ line:%l\ column:%c\ \ \ %M%Y%r%=%-14.(%t%)\ %p%%
  set statusline=   " clear the statusline, allow for rearranging parts
  set statusline+=%f\                "Path to the file, as typed or relative to current dir
  set statusline+=%#errormsg#        "change color
  set statusline+=%{&ff!='unix'?'['.&ff.']':''}   "display a warning if fileformat isnt unix
  set statusline+=%*                "reset color to normal statusline color
  set statusline+=%#errormsg#       "change color
  set statusline+=%{(&fenc!='utf-8'&&&fenc!='')?'['.&fenc.']':''}   "display a warning if file encoding isnt utf-8
  set statusline+=%*                "reset color to normal statusline color
  set statusline+=\ %y              "filetype
  set statusline+=%([%R%M]%)        "read-only (RO), modified (+) and unmodifiable (-) flags between braces
  set statusline+=%{'~'[&pm=='']}   "shows a '~' if in patchmode
  set statusline+=\ %{fugitive#statusline()}  "show Git info, via fugitive.git
  "set statusline+=\ (%{synIDattr(synID(line('.'),col('.'),0),'name')}) "DEBUG : display the current syntax item name
  set statusline+=%#error#          "change color
  set statusline+=%{&paste?'[paste]':''}    "display a warning if &paste is set
  set statusline+=%*                "reset color to normal statusline color
  set statusline+=%=                "right-align following items
  set statusline+=#%n               "buffer number
  set statusline+=\ %l/%L,          "current line number/total number of lines,
  set statusline+=%c                "Column number
  set statusline+=%V                " -{Virtual column number} (Not displayed if equal to 'c')
  set statusline+=\ %p%%            "percentage of lines through the file%
  set statusline+=\                 "trailing space
  if has('title')
    set titlestring=%t%(\ [%R%M]%)
  endif
endif
                                
" }}}
" Leader {{{

" Change the mapleader from \ to ,
let mapleader=","

" }}}
" Color scheme {{{

if &t_Co >= 256 || has("gui_running")
  set background=dark
  "colorscheme baycomb
  colorscheme mustang
  "colorscheme molokai
  "let g:solarized_termcolors=256
  "let g:solarized_bold = 1
  "let g:solarized_underline = 1
  "let g:solarized_italic = 1
  "colorscheme solarized
endif

if &t_Co > 2 || has("gui_running")
  syntax on                    " switch syntax highlighting on, when the terminal has colors
endif  

" }}}
" Useful abbreviations -------------------------------------------------------- {{{

" }}}
" Searching and movement ------------------------------------------------------ {{{

"clearing highlighted search
noremap <silent> <leader>/ :nohlsearch<CR>

" Change Working Directory to that of the current file
cmap cwd lcd %:p:h
cmap cd. lcd %:p:h

" Thanks to Steve Losh for this liberating tip
" See http://stevelosh.com/blog/2010/09/coming-home-to-vim
nnoremap / /\v

" Speed up scrolling of the viewport slightly
nnoremap <C-e> 2<C-e>
nnoremap <C-y> 2<C-y>

" }}}
" Directional Keys {{{

nnoremap <up> <nop>
nnoremap <down> <nop>
nnoremap <left> <nop>
nnoremap <right> <nop>
inoremap <up> <nop>
inoremap <down> <nop>
inoremap <left> <nop>
inoremap <right> <nop>  

" Easier moving in tabs and windows
noremap <C-j>  <C-w>j
noremap <C-k>  <C-w>k
noremap <C-l>  <C-w>l
noremap <C-h>  <C-w>h

" Fix home and end keybindings for screen, particularly on mac
" - for some reason this fixes the arrow keys too. huh.
" map [F $
" imap [F $
" map [H g0
" imap [H g0

" }}}
" Convenience mappings -------------------------------------------------------- {{{

" save changes
map <leader>s :w<CR>
" exit vim without saving any changes
map <leader>q :q!<CR>
" exit vim saving changes
map <leader>w :x<CR>
" use CTRL-F for omni completion
imap <C-F> 
" map CTRL-L to piece-wise copying of the line above the current one
imap <C-L> @@@<ESC>hhkywjl?@@@<CR>P/@@@<CR>3s
" map ,f to display all lines with keyword under cursor and ask which one to jump to
nmap <leader>f [I:let nr = input("Which one: ")<Bar>exe "normal " . nr ."[\t"<CR>
" open filename under cursor in a new window (use current file's working directory) 
nmap gf :new %:p:h/<cfile><CR>
" map <Alt-p> and <Alt-P> to paste below/above and reformat
nnoremap <M-P> P'[v']=
nnoremap <M-p> p'[v']=

" Clean whitespace
map <leader>W :%s/\s\+$//<cr>:let @/=''<CR>

" Yankring
nnoremap <silent> <F6> :YRShow<cr>
let g:yankring_history_dir = '~/.vim/tmp'

" Formatting, TextMate-style
nnoremap <leader>q gqip

" easier linewise reselection
nnoremap <leader>v v`]

" better completion
set completeopt=longest,menuone,preview

" this is a little tweak that is a time-saver while you’re building
" up your .vimrc. this effectively maps the ,ev and ,sv keys to
" edit/reload .vimrc. (i got this from derek wyatt’s .vimrc file.)
nmap <silent> <leader>ev :e $myvimrc<cr>
nmap <silent> <leader>sv :so $myvimrc<cr>

" sudo to write
cmap w!! w !sudo tee % >/dev/null

" quickly close the current window
"nnoremap <leader>q :q<cr>

" use q for formatting the current paragraph (or visual selection)
"vmap q gq
"nmap q gqap

" use ,d (or ,dd or ,dj or 20,dd) to delete a line without adding it to the
" yanked stack (also, in visual mode)
nmap <silent> <leader>d "_d
vmap <silent> <leader>d "_d  

" yank from the cursor to the end of the line, to be consistent with c and d.
nnoremap y y$
nnoremap d d$

" yank/paste to the os clipboard with ,y and ,p
nmap <leader>y "+y
nmap <leader>y "+yy
nmap <leader>p "+p
nmap <leader>p "+p   

" visual shifting (does not exit visual mode)
vnoremap < <gv
vnoremap > >gv

" quick alignment of text
nmap <leader>al :left<cr>
nmap <leader>ar :right<cr>
nmap <leader>ac :center<cr>

" pull word under cursor into lhs of a substitute (for quick search and
" replace)
nmap <leader>z :%s#\<<c-r>=expand("<cword>")<cr>\>#

" scratch
nmap <leader><tab> :sscratch<cr><c-w>x<c-j>  

" toggle paste: every vim user likes to enable auto-indenting of
" source code, so vim can intelligently position you cursor on the
" next line as you type. this has one big ugly consequence however:
" when you paste text into your terminal-based vim with a right
" mouse click, vim cannot know it is coming from a paste. to vim, it
" looks like text entered by someone who can type incredibly fast
" :) since vim thinks this is regular key strokes, it applies all
" auto-indenting and auto-expansion of defined abbreviations to the
" input, resulting in often cascading indents of paragraphs. there is
" an easy option to prevent this, however. you can temporarily switch
" to “paste mode”, simply by setting the following option:
set pastetoggle=<f8>

" reselect text that was just pasted with <leader>v
nnoremap <leader>v v`]  

" replaste
nnoremap <d-p> "_ddpv`]

" }}}
" folding --------------------------------------------------------------------- {{{

set foldenable                  " enable folding
set foldcolumn=0                " add a fold column
set foldmethod=marker           " detect triple-{ style fold markers
set foldlevelstart=99           " start out with nothing folded
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
                                " which commands trigger auto-unfold
                                
" space to toggle folds.
"nnoremap <space> za
"vnoremap <space> za

" make zo recursively open whatever top level fold we're in, no matter where the
" cursor happens to be.
"nnoremap zo zczo

"function! myfoldtext()
    "let line = getline(v:foldstart)

    "let nucolwidth = &fdc + &number * &numberwidth
    "let windowwidth = winwidth(0) - nucolwidth - 3
    "let foldedlinecount = v:foldend - v:foldstart

    "" expand tabs into spaces
    "let onetab = strpart('          ', 0, &tabstop)
    "let line = substitute(line, '\t', onetab, 'g')

    "let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    "let fillcharcount = windowwidth - len(line) - len(foldedlinecount) - 4
    "return line . ' …' . repeat(" ",fillcharcount) . foldedlinecount . ' '
"endfunction
"set foldtext=myfoldtext()

""" code folding options
nmap <leader>f0 :set foldlevel=0<cr>
nmap <leader>f1 :set foldlevel=1<cr>
nmap <leader>f2 :set foldlevel=2<cr>
nmap <leader>f3 :set foldlevel=3<cr>
nmap <leader>f4 :set foldlevel=4<cr>
nmap <leader>f5 :set foldlevel=5<cr>
nmap <leader>f6 :set foldlevel=6<cr>
nmap <leader>f7 :set foldlevel=7<cr>
nmap <leader>f8 :set foldlevel=8<cr>
nmap <leader>f9 :set foldlevel=9<cr>  

" }}}
" destroy infuriating keys ---------------------------------------------------- {{{

" fuck you, help key.
set fuoptions=maxvert,maxhorz
noremap <f1> :set invfullscreen<cr>
inoremap <f1> <esc>:set invfullscreen<cr>a

" fuck you too, manual key.
nnoremap k <nop>

" stop it, hash key.
inoremap # x<bs>#

" }}}
" various filetype-specific stuff --------------------------------------------- {{{


" invisible chars {{{  

" show invisible characters in all of these files
"au filetype vim setlocal list
"au filetype python,rst setlocal list
"au filetype ruby setlocal list
"au filetype javascript,css setlocal list

" }}}
" ruby {{{

"au filetype ruby setlocal expandtab shiftwidth=2 tabstop=2 softtabstop=2

" }}}
" c {{{

au filetype c setlocal foldmethod=syntax

" }}}
" html and htmldjango {{{

 " this function detects, based on html content, whether this is a
" django template, or a plain html file, and sets filetype accordingly
fun! s:detecthtmlvariant()
    let n = 1
    while n < 50 && n < line("$")
        " check for django
        if getline(n) =~ '{%\s*\(extends\|load\|block\|if\|for\|include\|trans\)\>'
            set ft=htmldjango.html
            return
        endif
        let n = n + 1
    endwhile
    " go with html
    set ft=html
endfun

"au bufnewfile,bufread *.html,*.htm call s:detecthtmlvariant()
" au bufnewfile,bufread *.html setlocal filetype=htmldjango

" auto-closing of html/xml tags
let g:closetag_default_xml=1
au filetype html let b:closetag_html_style=1
au filetype html,xml set listchars-=tab:>.          

"au bufnewfile,bufread *.html setlocal foldmethod=manual

" use <localleader>f to fold the current tag.
"au bufnewfile,bufread *.html nnoremap <buffer> <localleader>f vatzf
"au bufnewfile,bufread *.html nnoremap <buffer> vv vatv
"au bufnewfile,bufread *.htm nnoremap <buffer> <localleader>f vatzf
"au bufnewfile,bufread *.htm nnoremap <buffer> vv vatv

" use shift-return to turn this:
"     <tag>|</tag>
"
" into this:
"     <tag>
"         |
"     </tag>
"au bufnewfile,bufread *.html inoremap <buffer> <s-cr> <cr><esc>ka<cr>
"au bufnewfile,bufread *.html nnoremap <buffer> <s-cr> vit<esc>a<cr><esc>vito<esc>i<cr><esc>

" }}}
" css and lesscss {{{

autocmd filetype css set omnifunc=csscomplete#completecss
au bufnewfile,bufread *.less setlocal filetype=less

au bufnewfile,bufread *.css  setlocal foldmethod=marker
au bufnewfile,bufread *.less setlocal foldmethod=marker

au bufnewfile,bufread *.css  setlocal foldmarker={,}
au bufnewfile,bufread *.less setlocal foldmarker={,}

" use cc to change lines without borking the indentation.
au bufnewfile,bufread *.css  nnoremap <buffer> cc ddko
au bufnewfile,bufread *.less nnoremap <buffer> cc ddko

" use <leader>s to sort properties.  turns this:
"
"     p {
"         width: 200px;
"         height: 100px;
"         background: red;
"
"         ...
"     }
"
" into this:

"     p {
"         background: red;
"         height: 100px;
"         width: 200px;
"
"         ...
"     }
"
"au bufnewfile,bufread *.css  nnoremap <buffer> <localleader>s ?{<cr>jv/\v^\s*\}?$<cr>k:sort<cr>:noh<cr>
"au bufnewfile,bufread *.less nnoremap <buffer> <localleader>s ?{<cr>jv/\v^\s*\}?$<cr>k:sort<cr>:noh<cr>

" make {<cr> insert a pair of brackets in such a way that the cursor is correctly
" positioned inside of them and the following code doesn't get unfolded.
"au bufnewfile,bufread *.css  inoremap <buffer> {<cr> {}<left><cr>.<cr><esc>ka<bs><space><space>
"au bufnewfile,bufread *.less inoremap <buffer> {<cr> {}<left><cr>.<cr><esc>ka<bs><space><space>

" }}}
" javascript {{{

au filetype javascript setlocal foldmethod=marker
au filetype javascript setlocal foldmarker={,}
"au filetype javascript setlocal expandtab
"au filetype javascript setlocal listchars=trail:·,extends:#,nbsp:·
"au filetype javascript setlocal foldmethod=marker foldmarker={,}   

" }}}
" markdown {{{

au bufnewfile,bufread *.m*down setlocal filetype=markdown

" use <localleader>1/2/3 to add headings.
au filetype markdown nnoremap <buffer> <localleader>1 yypvr=
au filetype markdown nnoremap <buffer> <localleader>2 yypvr-
au filetype markdown nnoremap <buffer> <localleader>3 i### <esc>

" }}}
" vim {{{

au filetype vim setlocal foldmethod=marker
au filetype help setlocal textwidth=78
 " bind <f1> to show the keyword under cursor
" general help can still be entered manually, with :h
au filetype vim noremap <buffer> <f1> <esc>:help <c-r><c-w><cr>
au filetype vim noremap! <buffer> <f1> <esc>:help <c-r><c-w><cr>  

" }}}
" firefox {{{

au bufread,bufnewfile ~/library/caches/* setlocal buftype=nofile

" plugin settings ------------------------------------------------------------- {{{

" ack {{{

" map <leader>a :ack! 

" }}}
" nerd tree {{{

 " nerdtree settings {{{
" put focus to the nerd tree with f3 (tricked by quickly closing it and
" immediately showing it again, since there is no :nerdtreefocus command)
nmap <leader>n :nerdtreeclose<cr>:nerdtreetoggle<cr>
nmap <leader>m :nerdtreeclose<cr>:nerdtreefind<cr>
nmap <leader>n :nerdtreeclose<cr>
"map <f2> :nerdtreetoggle<cr>:nerdtreemirror<cr>

let nerdtreechdirmode=0

" store the bookmarks file
let nerdtreebookmarksfile=expand("~/.vim/tmp/nerdtreebookmarks")

" show the bookmarks table on startup
let nerdtreeshowbookmarks=1

" show hidden files, too
let nerdtreeshowfiles=1
let nerdtreeshowhidden=1

" quit on opening files from the tree
let nerdtreequitonopen=1

" highlight the selected entry in the tree
let nerdtreehighlightcursorline=1

" use a single click to fold/unfold directories and a double click to open
" files
let nerdtreemousemode=2

let nerdtreekeeptreeinnewtab=1

" don't display these kinds of files
let nerdtreeignore=[ '\.pyc$', '\.pyo$', '\.py\$class$', '\.obj$', '\.o$', '\.so$', '\.egg$', '^\.git$' ]
 
" }}}
" html5 {{{

let g:event_handler_attributes_complete = 0
let g:rdfa_attributes_complete = 0
let g:microdata_attributes_complete = 0
let g:atia_attributes_complete = 0

" }}}
" syntastic {{{

let g:syntastic_enable_signs=1
let g:syntastic_disabled_filetypes = ['html', 'python']

" }}}
" delimitmate {{{

au filetype * let b:delimitmate_autoclose = 1
" if using html auto complete (complete closing tag)
au filetype xml,html,xhtml let b:delimitmate_matchpairs = "(:),[:],{:}"

" }}}
" snipmate {{{

" shortcut for reloading snippets, useful when developing
nnoremap ,smr <esc>:exec reloadallsnippets()<cr>    

" }}}
" showmarks {{{

let showmarks_include = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"
" don't leave on by default, use :showmarkson to enable
let g:showmarks_enable = 0
" for marks a-z
highlight showmarkshll gui=bold guibg=lightblue guifg=blue
" for marks a-z
highlight showmarkshlu gui=bold guibg=lightred guifg=darkred
" for all other marks
highlight showmarkshlo gui=bold guibg=lightyellow guifg=darkyellow
" for multiple marks on the same line.
highlight showmarkshlm gui=bold guibg=lightgreen guifg=darkgreen

" }}}
" ctags variables {{{

" this will look in the current directory for 'tags', and work up the tree towards root until one is found. 
set tags=./tags;/,$home/vimtags
" c-\ - open the definition in a new tab
map <c-\> :tab split<cr>:exec("tag ".expand("<cword>"))<cr> 
" a-] - open the definition in a vertical split
map <a-]> :vsp <cr>:exec("tag ".expand("<cword>"))<cr>      

" }}}
" taglist variables {{{

nmap <leader>l :tlistclose<cr>:tlisttoggle<cr>
nmap <leader>l :tlistclose<cr>

" quit vim when the taglist window is the last open window
let tlist_exit_onlywindow=1         " quit when taglist is the last open window
let tlist_gainfocus_on_toggleopen=1 " put focus on the taglist window when it opens
"let tlist_process_file_always=1     " process files in the background, even when the taglist window isn't open
"let tlist_show_one_file=1           " only show tags from the current buffer, not all open buffers
let tlist_inc_winwidth=1            " increase window by 1 when growing

" shorten the time it takes to highlight the current tag (default is 4 secs)
" note that this setting influences vim's behaviour when saving swap files,
" but we have already turned off swap files (earlier)
"set updatetime=1000

" the default ctags in /usr/bin on the mac is gnu ctags, so change it to the
" exuberant ctags version in /usr/local/bin
let tlist_ctags_cmd = '/usr/local/bin/ctags'

let tlist_enable_fold_column=0 
" show function/method prototypes in the list
let tlist_display_prototype=1

" don't show scope info
let tlist_display_tag_scope=0

" show taglist window on the right
let tlist_use_right_window=1  

let tlist_auto_highlight_tag = 1
let tlist_auto_update = 1
let tlist_file_fold_auto_close = 1
let tlist_use_singleclick = 1

let g:ctags_statusline=1
" override how taglist does javascript
let g:tlist_javascript_settings = 'javascript;f:function;c:class;m:method;p:property;v:global'  

" }}}
" json {{{

nmap <leader>jt <esc>:%!python -m json.tool<cr><esc>:set filetype=json<cr>                       

" }}}
" easymotion {{{

let g:easymotion_do_mapping = 0

nnoremap <silent> <leader>f      :call easymotionf(0, 0)<cr>
vnoremap <silent> <leader>f :<c-u>call easymotionf(1, 0)<cr>

nnoremap <silent> <leader>f      :call easymotionf(0, 1)<cr>
vnoremap <silent> <leader>f :<c-u>call easymotionf(1, 1)<cr>

"}}}
" autoclose {{{

nmap <leader>x <plug>toggleautoclosemappings

" }}}
" scratch {{{

command! scratchtoggle call scratchtoggle()
function! scratchtoggle() " {{{
  if exists("w:is_scratch_window")
    unlet w:is_scratch_window
    exec "q"
  else
    exec "normal! :sscratch\<cr>\<c-w>j:resize 13\<cr>"
    let w:is_scratch_window = 1
  endif
endfunction " }}}
nnoremap <silent> <leader><tab> :scratchtoggle<cr>

" }}}
" orgmode {{{
let g:org_plugins = ['showhide', '|', 'navigator', 'editstructure', '|', 'todo', 'misc']

let g:org_todo_keywords = ['todo', 'hold', '|', 'done']
let g:org_debug = 1

" }}}
" synstack -------------------------------------------------------------------- {{{

" show the stack of syntax hilighting classes affecting whatever is under the
" cursor.
function! synstack() " {{{
  if !exists("*synstack")
    return
  endif

  echo map(synstack(line('.'), col('.')), 'synidattr(v:val, "name")')
endfunc " }}}

nmap <m-s> :call synstack()<cr>

" }}}
" text objects ---------------------------------------------------------------- {{{

" shortcut for [] {{{

"onoremap id i[
"onoremap ad a[
"vnoremap id i[
"vnoremap ad a[

" }}}
" next/last () {{{
"vnoremap <silent> inb :<c-u>normal! f(vib<cr>
"onoremap <silent> inb :<c-u>normal! f(vib<cr>
"vnoremap <silent> anb :<c-u>normal! f(vab<cr>
"onoremap <silent> anb :<c-u>normal! f(vab<cr>
"vnoremap <silent> in( :<c-u>normal! f(vi(<cr>
"onoremap <silent> in( :<c-u>normal! f(vi(<cr>
"vnoremap <silent> an( :<c-u>normal! f(va(<cr>
"onoremap <silent> an( :<c-u>normal! f(va(<cr>

"vnoremap <silent> ilb :<c-u>normal! f)vib<cr>
"onoremap <silent> ilb :<c-u>normal! f)vib<cr>
"vnoremap <silent> alb :<c-u>normal! f)vab<cr>
"onoremap <silent> alb :<c-u>normal! f)vab<cr>
"vnoremap <silent> il( :<c-u>normal! f)vi(<cr>
"onoremap <silent> il( :<c-u>normal! f)vi(<cr>
"vnoremap <silent> al( :<c-u>normal! f)va(<cr>
"onoremap <silent> al( :<c-u>normal! f)va(<cr>
" }}}
" next/last {} {{{
"vnoremap <silent> inb :<c-u>normal! f{vib<cr>
"onoremap <silent> inb :<c-u>normal! f{vib<cr>
"vnoremap <silent> anb :<c-u>normal! f{vab<cr>
"onoremap <silent> anb :<c-u>normal! f{vab<cr>
"vnoremap <silent> in{ :<c-u>normal! f{vi{<cr>
"onoremap <silent> in{ :<c-u>normal! f{vi{<cr>
"vnoremap <silent> an{ :<c-u>normal! f{va{<cr>
"onoremap <silent> an{ :<c-u>normal! f{va{<cr>

"vnoremap <silent> ilb :<c-u>normal! f}vib<cr>
"onoremap <silent> ilb :<c-u>normal! f}vib<cr>
"vnoremap <silent> alb :<c-u>normal! f}vab<cr>
"onoremap <silent> alb :<c-u>normal! f}vab<cr>
"vnoremap <silent> il{ :<c-u>normal! f}vi{<cr>
"onoremap <silent> il{ :<c-u>normal! f}vi{<cr>
"vnoremap <silent> al{ :<c-u>normal! f}va{<cr>
"onoremap <silent> al{ :<c-u>normal! f}va{<cr>
" }}}
" next/last [] {{{
"vnoremap <silent> ind :<c-u>normal! f[vi[<cr>
"onoremap <silent> ind :<c-u>normal! f[vi[<cr>
"vnoremap <silent> and :<c-u>normal! f[va[<cr>
"onoremap <silent> and :<c-u>normal! f[va[<cr>
"vnoremap <silent> in[ :<c-u>normal! f[vi[<cr>
"onoremap <silent> in[ :<c-u>normal! f[vi[<cr>
"vnoremap <silent> an[ :<c-u>normal! f[va[<cr>
"onoremap <silent> an[ :<c-u>normal! f[va[<cr>

"vnoremap <silent> ild :<c-u>normal! f]vi[<cr>
"onoremap <silent> ild :<c-u>normal! f]vi[<cr>
"vnoremap <silent> ald :<c-u>normal! f]va[<cr>
"onoremap <silent> ald :<c-u>normal! f]va[<cr>
"vnoremap <silent> il[ :<c-u>normal! f]vi[<cr>
"onoremap <silent> il[ :<c-u>normal! f]vi[<cr>
"vnoremap <silent> al[ :<c-u>normal! f]va[<cr>
"onoremap <silent> al[ :<c-u>normal! f]va[<cr>
"" }}}
" next/last <> {{{
"vnoremap <silent> in< :<c-u>normal! f<vi<<cr>
"onoremap <silent> in< :<c-u>normal! f<vi<<cr>
"vnoremap <silent> an< :<c-u>normal! f<va<<cr>
"onoremap <silent> an< :<c-u>normal! f<va<<cr>

"vnoremap <silent> il< :<c-u>normal! f>vi<<cr>
"onoremap <silent> il< :<c-u>normal! f>vi<<cr>
"vnoremap <silent> al< :<c-u>normal! f>va<<cr>
"onoremap <silent> al< :<c-u>normal! f>va<<cr>
" }}}
" next '' {{{
"vnoremap <silent> in' :<c-u>normal! f'vi'<cr>
"onoremap <silent> in' :<c-u>normal! f'vi'<cr>
"vnoremap <silent> an' :<c-u>normal! f'va'<cr>
"onoremap <silent> an' :<c-u>normal! f'va'<cr>

"vnoremap <silent> il' :<c-u>normal! f'vi'<cr>
"onoremap <silent> il' :<c-u>normal! f'vi'<cr>
"vnoremap <silent> al' :<c-u>normal! f'va'<cr>
"onoremap <silent> al' :<c-u>normal! f'va'<cr>
" }}}
" next "" {{{
"vnoremap <silent> in" :<c-u>normal! f"vi"<cr>
"onoremap <silent> in" :<c-u>normal! f"vi"<cr>
"vnoremap <silent> an" :<c-u>normal! f"va"<cr>
"onoremap <silent> an" :<c-u>normal! f"va"<cr>

"vnoremap <silent> il" :<c-u>normal! f"vi"<cr>
"onoremap <silent> il" :<c-u>normal! f"vi"<cr>
"vnoremap <silent> al" :<c-u>normal! f"va"<cr>
"onoremap <silent> al" :<c-u>normal! f"va"<cr>
" }}}

" }}}
" quickreturn ----------------------------------------------------------------- {{{

inoremap <c-cr> <esc>a<cr>
inoremap <s-cr> <esc>a:<cr>

" }}}
" error toggles --------------------------------------------------------------- {{{

" tame the quickfix window (open/close using f4)
nmap <silent> <f4> :qfix<cr>

command! -bang -nargs=? qfix call qfixtoggle(<bang>0)
function! qfixtoggle(forced)
  if exists("g:qfix_win") && a:forced == 0
    cclose
    unlet g:qfix_win
  else
    copen 10
    let g:qfix_win = bufnr("$")
  endif
endfunction

" }}}
" persistent echo ------------------------------------------------------------- {{{

" http://vim.wikia.com/wiki/make_echo_seen_when_it_would_otherwise_disappear_and_go_unseen
"
" further improvement in restoration of the &updatetime. to make this
" usable in the plugins, we want it to be safe for the case when
" two plugins use same this same technique. two independent
" restorations of &ut can run in unpredictable sequence. in order to
" make it safe, we add additional check in &ut restoration.
let s:pecho=''
fu! s:pecho(msg)
  let s:hold_ut=&ut | if &ut>1|let &ut=1|en
  let s:pecho=a:msg
  aug pecho
    au cursorhold * if s:pecho!=''|echo s:pecho
          \|let s:pecho=''|if s:hold_ut > &ut |let &ut=s:hold_ut|en|en
          \|aug pecho|exe 'au!'|aug end|aug! pecho
  aug end
endf

" }}}
" open quoted ----------------------------------------------------------------- {{{

nnoremap <silent> ø :openquoted<cr>
command! openquoted call openquoted()

" open the file in the current (or next) set of quotes.
function! openquoted() " {{{
    let @r = ''

    exe 'normal! vi' . "'" . '"ry'

    if len(@r) == 0
        exe 'normal! i' . '"' . '"ry'
    endif

    if len(@r) == 0
        exe 'normal! "ry'
        let @r = ''
    endif

    exe "silent !open ." . @r
endfunction " }}}


" restore cursor position upon reopening files {{{
autocmd bufreadpost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
" }}}

" common abbreviations / misspellings {{{
source ~/.vim/autocorrect.vim
" }}}

" extra vi-compatibility {{{
" set extra vi-compatible options
set cpoptions+=$     " when changing a line, don't redisplay, but put a '$' at
                     " the end during the change
set formatoptions-=o " don't start new lines w/ comment leader on pressing 'o'
au filetype vim set formatoptions-=o
                     " somehow, during vim filetype detection, this gets set
                     " for vim files, so explicitly unset it again
" }}}

" extra user or machine specific settings {{{
source ~/.user.vim
" }}}

" creating underline/overline headings for markup languages
" inspired by http://sphinx.pocoo.org/rest.html#sections
nnoremap <leader>1 yypvr=jyypvr=
nnoremap <leader>2 yypvr*jyypvr*
nnoremap <leader>3 yypvr=
nnoremap <leader>4 yypvr-
nnoremap <leader>5 yypvr^
nnoremap <leader>6 yypvr"   

" }}}
" macvim ---------------------------------------------------------------------- {{{

if has('gui_running')
    set guifont=anonymous\ pro:h14   
    set guioptions-=t          	" remove the toolbar
    set lines=96               	" 40 lines of text instead of 24,
    set transparency=5          " make the window slightly transparent

    " remove all the ui cruft
    set go-=t
    set go-=l
    set go-=l
    set go-=r
    set go-=r

    " peepopen
    if has("gui_macvim")
      map <leader><leader> <plug>peepopen
    end

    highlight spellbad term=underline gui=undercurl guisp=orange

    " use a line-drawing char for pretty vertical splits.
    set fillchars=vert:│

    " different cursors for different modes.
    set guicursor=n-c:block-cursor-blinkon0
    set guicursor+=v:block-vcursor-blinkon0
    set guicursor+=i-ci:ver20-icursor

    " use the normal hig movements, except for m-up/down
    let macvim_skip_cmd_opt_movement = 1
    no   <d-left>       <home>
    no!  <d-left>       <home>
    no   <m-left>       <c-left>
    no!  <m-left>       <c-left>

    no   <d-right>      <end>
    no!  <d-right>      <end>
    no   <m-right>      <c-right>
    no!  <m-right>      <c-right>

    no   <d-up>         <c-home>
    ino  <d-up>         <c-home>
    imap <m-up>         <c-o>{

    no   <d-down>       <c-end>
    ino  <d-down>       <c-end>
    imap <m-down>       <c-o>}

    imap <m-bs>         <c-w>
    inoremap <d-bs>     <esc>my0c`y
else
  set term=builtin_ansi       " make arrow and other keys work
endif

" }}}
