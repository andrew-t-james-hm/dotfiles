#!/bin/bash

# Path to the bash it configuration
export BASH_IT="${HOME}/.bash"

# handle the case when editing remote files through emacs
if [[ "$TERM" == "dumb" ]]; then
  . "${BASH_IT}/lib/custom.sh"
  return
fi

# TODO Test these
# if [[ "$TERM" = "dumb" ]]; then
#   PS1="> "
#   return
# fi

# If not running interactively, don't do anything
# [ -z "$PS1" ] && return
# [[ $- == *i*  ]] && echo 'Interactive' || echo 'Not interactive'
[[ $- != *i*  ]] && return

# While `mvim` is running it keeps calling my login shell, do not know why, till
# then, lets just disable it the best way we know how to. If MYVIMRC environment
# variable does not work, there is also VIMRUNTIME to check for.
[[ -n "$MYVIMRC" ]] && return

function osx_upgrade_bash4 {
  local new_version
  new_version=$(bash --version | head -n1 | sed 's/.* version \([^ ]*\).*/\1/')
  if [[ $new_version > $BASH_VERSION ]]; then
    echo "Found Bash v$new_version"
    # and try preserving all the invocation options
    exec -l bash -l${-//[chimBH]/} # "$@"
  fi
}

# exec into bash >= 4, when available (for login shells)
if [[ ${BASH_VERSINFO[0]} -lt 4 ]]; then
  if [[ -n $INSIDE_EMACS ]]; then
    osx_upgrade_bash4
  elif [[ $0 = -bash ]] && shopt -qp login_shell; then
    osx_upgrade_bash4
  fi
fi

if hash gdate 2>/dev/null; then
  tic=$(($(gdate +%s%N)/1000000))
fi

# Path to the dfm repo configuration
export DFM_REPO="${HOME}/.dotfiles"

declare -a preexec_functions
declare -a precmd_functions
declare -a on_exit_items

function add_on_exit() {
  local n=${#on_exit_items[*]}
  on_exit_items[$n]="$*"
}
add_on_exit osx_upgrade_bash4

# No dependency, simple and useful utilities
. "${BASH_IT}/lib/vars.sh"
. "${BASH_IT}/lib/funcs.sh"

if [ "$__dot_system_type" == "Darwin" ]; then
    ulimit -n 65536 65536

    export DICPATH=$HOME/Library/Spelling
    export DICTIONARY=en_US

    if hash brew 2>/dev/null; then

      brew_cache="${HOME}/.brew-init-bash"
      if [ -f "$brew_cache" ]; then
        . "$brew_cache"
        __unserialise __dot_brew_list "$__dot_brew_list"
        __unserialise __dot_brew_taps "$__dot_brew_taps"
        __unserialise __dot_cask_list "$__dot_cask_list"
      else
        BREW_HOME="$(brew --prefix)"
        export BREW_HOME

        __dot_brew_list=($(brew list | sed 's/:.*//'))
        __dot_brew_taps=($(brew tap | sed 's/:.*//'))
        __dot_cask_list=($(brew cask list | sed 's/:.*//'))
      fi
      unset brew_cache

      HOMEBREW_CASK_OPTS="--appdir=/Applications"
      export HOMEBREW_CASK_OPTS

    fi

    if brew_contains_element "bash-completion"; then
        BASH_COMP_TARGET="$BREW_HOME/etc/bash_completion"
        if [ "${BASH_VERSINFO[0]}" -le 3 ] && [ -f "${BASH_COMP_TARGET}" ]; then
          . "${BASH_COMP_TARGET}"
        fi
        unset BASH_COMP_TARGET
    elif brew_contains_element "bash-completion2"; then
        BASH_COMP_TARGET="$BREW_HOME/share/bash-completion/bash_completion"

        if [ "${BASH_VERSINFO[0]}" -ge 4 ] && [ -f "${BASH_COMP_TARGET}" ]; then
          . "${BASH_COMP_TARGET}"
        fi
        unset BASH_COMP_TARGET
    fi
elif [ "$__dot_system_type" == "Linux" ]; then
    if ! shopt -oq posix; then
        if [ -f /usr/share/bash-completion/bash_completion ]; then
            . /usr/share/bash-completion/bash_completion
        elif [ -f /etc/bash_completion ]; then
            . /etc/bash_completion
        fi
    fi
fi

# echo "Found ${#__dot_brew_list[@]} installed formulas"
# echo "Found ${#__dot_brew_taps[@]} taps"
# echo "Found ${#__dot_cask_list[@]} installed applications"

# detect ssh or not, but no bother in emacs term
if [ -z "$INSIDE_EMACS" ]; then
  # http://unix.stackexchange.com/questions/9605/
  if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
    SESSION_TYPE=remote/ssh
    export SESSION_TYPE
  else
    case $(ps -o comm= -p $PPID) in
      sshd|*/sshd) export SESSION_TYPE=remote/ssh;;
    esac
  fi
fi

# Set mveditor/MacVim as EDITOR.
if [ -f "${BASH_IT}/mveditor.sh" ]; then
    EDITOR="${BASH_IT}/mveditor.sh"
    GIT_EDITOR="${BASH_IT}/mveditor.sh"
else
    EDITOR="vim"
    GIT_EDITOR="vim"
fi
export EDITOR
export GIT_EDITOR

# Don't check mail when opening terminal.
unset MAILCHECK

# Add tab completion for sudo.
complete -cf sudo

# vim and gnome-terminal have support for 256 colours in fedora 8 at least
# Note debian/ubuntu users need to install the ncurses-term package for this
# Note this should be set in ~/.profile for Fedora startup scripts to
# setup LS_COLORS correctly.
if [[ $COLORTERM = gnome-* && $TERM = xterm ]]  && infocmp gnome-256color >/dev/null 2>&1; then
    TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
    TERM=xterm-256color
fi
export TERM

# General Startup #
umask 002
mesg n

# nice things
shopt -s extglob      # extended globbing capabilities

# Prevent file overwrite on stdout redirection
set -o noclobber

# these options are only availabe in Bash4
if [ "${BASH_VERSINFO[0]}" -ge 4 ]; then
  # Prepend cd to directory names automatically, type 'dir' instead 'cd dir'
  shopt -s autocd 2> /dev/null
  shopt -s dirspell     # correct typos when tab-completing names
  shopt -s globstar     # enable **
  # Correct spelling errors in arguments supplied to cd
  shopt -s cdspell 2> /dev/null

  # Automatically trim long paths in the prompt (requires Bash 4.x)
  PROMPT_DIRTRIM=2
fi

# This defines where cd looks for targets
# Add the directories you want to have fast access to, separated by colon
# Ex: CDPATH=".:~:~/projects" will look for targets in the current working directory, in home and in the ~/projects folder
# CDPATH="."

# This allows you to bookmark your favorite places across the file system
# Define a variable containing a path and you will be able to cd into it regardless of the directory you're in
shopt -s cdable_vars

# disable completion command names when pressing tab at the start of a line
shopt -s no_empty_cmd_completion

# Check the window size after each command and, if necessary, update the values
# of LINES and COLUMNS.
shopt -s checkwinsize

# Case-insensitive globbing (used in pathname expansion)
shopt -s nocaseglob

# Use color output for less.
export LESS="-rRSM~gIsw"

# Don't clear the screen after quitting a manual page
export MANPAGER="less -X"

# Change this to your console based IRC client of choice.
export IRC_CLIENT='irssi'

# md = mode doublebright (bold), us = underline start, so = standout
# so is used for the line at the bottom and search highlights
export LESS_TERMCAP_md=$'\e[31m'
export LESS_TERMCAP_us=$'\e[32m'
export LESS_TERMCAP_so=$'\e[44;33m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'

export THEME_PROMPT_CLOCK_FORMAT="%l:%M"
export THEME_BATTERY_PERCENTAGE_CHECK=false
export THEME_CLOCK_CHECK=false

## THEMES

if [ -z "$INSIDE_EMACS" ]; then
  # Lock and load a custom theme file location /.bash/themes/
  export BASH_IT_THEME='oh-my-git'
else
  # Apple Terminal drops `update_terminal_cwd` to PROMPT_COMMAND in /etc/bashrc
  unset PROMPT_COMMAND
  export BASH_IT_THEME='oh-my-git-pure'
fi

# Load colors first so they can be use in base theme
. "${BASH_IT}/themes/colors.theme.bash"
. "${BASH_IT}/themes/base.theme.bash"

# library
lib="${BASH_IT}/lib/*.bash"
for config_file in $lib
do
  . "$config_file"
done
unset config_file
unset lib

path_munge "/usr/local/sbin"
path_munge "/usr/local/bin"
path_munge "${HOME}/.cabal/bin"

if [ "$__dot_system_type" == "Darwin" ]; then
    export CHEATCOLORS=true
    export HTML_TIDY=$HOME/.tidyrc
    export TLSOURCE=en TLTARGET=es
    export PERL_LOCAL_LIB_ROOT="${HOME}/perl5:$PERL_LOCAL_LIB_ROOT";
    export PERL_MB_OPT="--install_base "${HOME}/perl5"";
    export PERL_MM_OPT="INSTALL_BASE=${HOME}/perl5";
    export PERL5LIB="${HOME}/perl5/lib/perl5:$PERL5LIB";

    if brew_contains_element "openconnect"; then
        export VPNC_SCRIPT="${BREW_HOME}/etc/vpnc-script"
    fi

    if cask_contains_element "vagrant"; then
        export VAGRANT_CHECKPOINT_DISABLE=1
        export VAGRANT_HOME="$HOME/.vagrant.d"
        export VAGRANT_DOTFILE_PATH=".vagrant-$(hostname)"
        # Time Machine ignore this directory
        export VAGRANT_VMWARE_CLONE_DIRECTORY="${HOME}/.cache/vagrant"
    fi
elif [ "$__dot_system_type" == "Linux" ]; then
    path_munge "/usr/local/linuxbrew/bin"

    # if [ ${#__dot_brew_list[@]} -gt 0 ]; then
    if [ -n "$BREW_HOME" ]; then
        # Fix checks for gcc compiler when not present when `--env=inherit` specified
        export HOMEBREW_TEMP="${BREW_HOME}/tmp"
        export MANPATH="${BREW_HOME}/share/man:$MANPATH"
        export INFOPATH="${BREW_HOME}/share/info:$INFOPATH"
    fi

    dpkg -s vagrant &>/dev/null || {
        export VAGRANT_CHECKPOINT_DISABLE=1
        export VAGRANT_HOME=~/.vagrant.d
        export VAGRANT_DOTFILE_PATH=".vagrant-$(hostname)"
    }

    dpkg -s vpnc-scripts &>/dev/null || {
        export VPNC_SCRIPT=/usr/share/vpnc-scripts/vpnc-script
    }
fi

# Helper function loading various enable-able files
function load_bash_it_files() {
  subdirectory="$1"
  if [ ! -d "${BASH_IT}/${subdirectory}" ]; then
    continue
  fi
  FILES="${BASH_IT}/${subdirectory}/*.bash"
  for bash_config_file in $FILES; do
    if [ -e "${bash_config_file}" ]; then
        . $bash_config_file
        # mytime="$(time (source $bash_config_file) 2>&1 1>/dev/null )"
        # echo "${bash_config_file}: ${mytime}"
    fi
  done
}
add_on_exit load_bash_it_files

# Load enabled plugins, aliases, and completion
for file_type in "plugins" "completion" "aliases"; do
  load_bash_it_files $file_type
done

path_munge "${HOME}/.bin"
PATH=$(path_strip "$PATH" "\./bin")
path_prepend "./bin"

# Load custom aliases, completion, plugins
for file_type in "plugins" "completion" "aliases"; do
  if [ -e "${BASH_IT}/${file_type}/custom.${file_type}.bash" ]; then
    . "${BASH_IT}/${file_type}/custom.${file_type}.bash"
  fi
done
unset file_type

# Use the Keychain to store your sudo passwords on the cli. Start by adding a
# new keychain, I choose to name it "Local Accounts" and create a master
# password for that keychain. Note that "login" is your default keychain. Now
# you can add your accounts to that keychain.
if [ "$__dot_system_type" == "Darwin" ]; then
  export SUDO_ASKPASS="$HOME/.bin/sudo_askpass"
  alias sudo="sudo -A "
fi

if [[ $PROMPT ]]; then
    export PS1="\["$PROMPT"\]"
fi

# Adding Support for other OSes
PREVIEW="less"
[ -s /usr/bin/gloobus-preview ] && PREVIEW="gloobus-preview"
[ -s /Applications/Preview.app ] && PREVIEW="/Applications/Preview.app"
export PREVIEW

# TODO: Add preexec to time machine node_modules folders
function title {
  true # no op
}

# Default do-nothing implementation of preexec.
function preexec () {
    true
}

# Default do-nothing implementation of precmd.
function precmd () {
    true
}

function iterm2_preexec_hook() {
    . "${BASH_IT}/preexec/iterm2-preexec.sh"

    preexec_functions+=(iterm2_preexec_invoke_cmd)

    # This is necessary so the first command line will have a hostname and current directory.
    iterm2_print_state_data
    iterm2_print_version_number
}

# https://github.com/rcaloras/bash-preexec
# TODO: Migrate to brew `bash-preexec`
. "${BASH_IT}/preexec/bash-preexec.sh"
. "${BASH_IT}/preexec/npm-preexec.sh"
. "${BASH_IT}/preexec/git-preexec.sh"

if [ -z "$INSIDE_EMACS" ]; then
    if [ "${TERM_PROGRAM:-""}" != "" ]; then
        if [ "$TERM_PROGRAM" == "iTerm.app" ]; then
            iterm2_preexec_hook
            function title {
                echo -ne "\033]0;"$*"\007"
            }
        fi
    elif [ -n "$SESSION_TYPE" ]; then
        iterm2_preexec_hook
    fi
fi

. "${BASH_IT}/lib/custom.sh"

if hash gdate 2>/dev/null; then
    toc=$(($(gdate +%s%N)/1000000))
    delta=$((toc - tic))
    LC_NUMERIC=C LC_COLLATE=C
    printf 'Bash loaded in %g secs\n' "$(bc <<< "scale=3; ${delta}/1000")"
    unset tic toc delta
else
    echo "Bash loaded in $SECONDS secs"
fi

for i in "${on_exit_items[@]}"; do
  # echo "on_exit: $i"
  unset "$i"
done
unset add_on_exit
unset on_exit_items
